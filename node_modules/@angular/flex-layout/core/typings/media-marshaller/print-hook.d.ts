import { MediaChange } from '../media-change';
import { BreakPoint } from '../breakpoints/break-point';
import { LayoutConfigOptions } from '../tokens/library-config';
import { BreakPointRegistry, OptionalBreakPoint } from '../breakpoints/break-point-registry';
/**
 * Interface to apply PrintHook to call anonymous `target.updateStyles()`
 */
import * as ɵngcc0 from '@angular/core';
export interface HookTarget {
    activatedBreakpoints: BreakPoint[];
    updateStyles(): void;
}
export declare const BREAKPOINT_PRINT: {
    alias: string;
    mediaQuery: string;
    priority: number;
};
/**
 * PrintHook - Use to intercept print MediaQuery activations and force
 *             layouts to render with the specified print alias/breakpoint
 *
 * Used in MediaMarshaller and MediaObserver
 */
export declare class PrintHook {
    protected breakpoints: BreakPointRegistry;
    protected layoutConfig: LayoutConfigOptions;
    constructor(breakpoints: BreakPointRegistry, layoutConfig: LayoutConfigOptions);
    /** Add 'print' mediaQuery: to listen for matchMedia activations */
    withPrintQuery(queries: string[]): string[];
    /** Is the MediaChange event for any 'print' @media */
    isPrintEvent(e: MediaChange): Boolean;
    /** What is the desired mqAlias to use while printing? */
    readonly printAlias: string[];
    /** Lookup breakpoints associated with print aliases. */
    readonly printBreakPoints: BreakPoint[];
    /** Lookup breakpoint associated with mediaQuery */
    getEventBreakpoints({ mediaQuery }: MediaChange): BreakPoint[];
    /** Update event with printAlias mediaQuery information */
    updateEvent(event: MediaChange): MediaChange;
    /**
     * Prepare RxJs filter operator with partial application
     * @return pipeable filter predicate
     */
    interceptEvents(target: HookTarget): (event: MediaChange) => void;
    /** Stop mediaChange event propagation in event streams */
    blockPropagation(): (event: MediaChange) => boolean;
    /**
     * Save current activateBreakpoints (for later restore)
     * and substitute only the printAlias breakpoint
     */
    protected startPrinting(target: HookTarget, bpList: OptionalBreakPoint[]): void;
    /** For any print de-activations, reset the entire print queue */
    protected stopPrinting(target: HookTarget): void;
    /**
     * To restore pre-Print Activations, we must capture the proper
     * list of breakpoint activations BEFORE print starts. OnBeforePrint()
     * is not supported; so 'print' mediaQuery activations must be used.
     *
     * >  But activated breakpoints are deactivated BEFORE 'print' activation.
     *
     * Let's capture all de-activations using the following logic:
     *
     *  When not printing:
     *    - clear cache when activating non-print breakpoint
     *    - update cache (and sort) when deactivating
     *
     *  When printing:
     *    - sort and save when starting print
     *    - restore as activatedTargets and clear when stop printing
     */
    collectActivations(event: MediaChange): void;
    /** Is this service currently in Print-mode ? */
    private isPrinting;
    private queue;
    private deactivations;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PrintHook>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<PrintHook>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJpbnQtaG9vay5kLnRzIiwic291cmNlcyI6WyJwcmludC1ob29rLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1FQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1lZGlhQ2hhbmdlIH0gZnJvbSAnLi4vbWVkaWEtY2hhbmdlJztcbmltcG9ydCB7IEJyZWFrUG9pbnQgfSBmcm9tICcuLi9icmVha3BvaW50cy9icmVhay1wb2ludCc7XG5pbXBvcnQgeyBMYXlvdXRDb25maWdPcHRpb25zIH0gZnJvbSAnLi4vdG9rZW5zL2xpYnJhcnktY29uZmlnJztcbmltcG9ydCB7IEJyZWFrUG9pbnRSZWdpc3RyeSwgT3B0aW9uYWxCcmVha1BvaW50IH0gZnJvbSAnLi4vYnJlYWtwb2ludHMvYnJlYWstcG9pbnQtcmVnaXN0cnknO1xuLyoqXG4gKiBJbnRlcmZhY2UgdG8gYXBwbHkgUHJpbnRIb29rIHRvIGNhbGwgYW5vbnltb3VzIGB0YXJnZXQudXBkYXRlU3R5bGVzKClgXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSG9va1RhcmdldCB7XG4gICAgYWN0aXZhdGVkQnJlYWtwb2ludHM6IEJyZWFrUG9pbnRbXTtcbiAgICB1cGRhdGVTdHlsZXMoKTogdm9pZDtcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IEJSRUFLUE9JTlRfUFJJTlQ6IHtcbiAgICBhbGlhczogc3RyaW5nO1xuICAgIG1lZGlhUXVlcnk6IHN0cmluZztcbiAgICBwcmlvcml0eTogbnVtYmVyO1xufTtcbi8qKlxuICogUHJpbnRIb29rIC0gVXNlIHRvIGludGVyY2VwdCBwcmludCBNZWRpYVF1ZXJ5IGFjdGl2YXRpb25zIGFuZCBmb3JjZVxuICogICAgICAgICAgICAgbGF5b3V0cyB0byByZW5kZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHByaW50IGFsaWFzL2JyZWFrcG9pbnRcbiAqXG4gKiBVc2VkIGluIE1lZGlhTWFyc2hhbGxlciBhbmQgTWVkaWFPYnNlcnZlclxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBQcmludEhvb2sge1xuICAgIHByb3RlY3RlZCBicmVha3BvaW50czogQnJlYWtQb2ludFJlZ2lzdHJ5O1xuICAgIHByb3RlY3RlZCBsYXlvdXRDb25maWc6IExheW91dENvbmZpZ09wdGlvbnM7XG4gICAgY29uc3RydWN0b3IoYnJlYWtwb2ludHM6IEJyZWFrUG9pbnRSZWdpc3RyeSwgbGF5b3V0Q29uZmlnOiBMYXlvdXRDb25maWdPcHRpb25zKTtcbiAgICAvKiogQWRkICdwcmludCcgbWVkaWFRdWVyeTogdG8gbGlzdGVuIGZvciBtYXRjaE1lZGlhIGFjdGl2YXRpb25zICovXG4gICAgd2l0aFByaW50UXVlcnkocXVlcmllczogc3RyaW5nW10pOiBzdHJpbmdbXTtcbiAgICAvKiogSXMgdGhlIE1lZGlhQ2hhbmdlIGV2ZW50IGZvciBhbnkgJ3ByaW50JyBAbWVkaWEgKi9cbiAgICBpc1ByaW50RXZlbnQoZTogTWVkaWFDaGFuZ2UpOiBCb29sZWFuO1xuICAgIC8qKiBXaGF0IGlzIHRoZSBkZXNpcmVkIG1xQWxpYXMgdG8gdXNlIHdoaWxlIHByaW50aW5nPyAqL1xuICAgIHJlYWRvbmx5IHByaW50QWxpYXM6IHN0cmluZ1tdO1xuICAgIC8qKiBMb29rdXAgYnJlYWtwb2ludHMgYXNzb2NpYXRlZCB3aXRoIHByaW50IGFsaWFzZXMuICovXG4gICAgcmVhZG9ubHkgcHJpbnRCcmVha1BvaW50czogQnJlYWtQb2ludFtdO1xuICAgIC8qKiBMb29rdXAgYnJlYWtwb2ludCBhc3NvY2lhdGVkIHdpdGggbWVkaWFRdWVyeSAqL1xuICAgIGdldEV2ZW50QnJlYWtwb2ludHMoeyBtZWRpYVF1ZXJ5IH06IE1lZGlhQ2hhbmdlKTogQnJlYWtQb2ludFtdO1xuICAgIC8qKiBVcGRhdGUgZXZlbnQgd2l0aCBwcmludEFsaWFzIG1lZGlhUXVlcnkgaW5mb3JtYXRpb24gKi9cbiAgICB1cGRhdGVFdmVudChldmVudDogTWVkaWFDaGFuZ2UpOiBNZWRpYUNoYW5nZTtcbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIFJ4SnMgZmlsdGVyIG9wZXJhdG9yIHdpdGggcGFydGlhbCBhcHBsaWNhdGlvblxuICAgICAqIEByZXR1cm4gcGlwZWFibGUgZmlsdGVyIHByZWRpY2F0ZVxuICAgICAqL1xuICAgIGludGVyY2VwdEV2ZW50cyh0YXJnZXQ6IEhvb2tUYXJnZXQpOiAoZXZlbnQ6IE1lZGlhQ2hhbmdlKSA9PiB2b2lkO1xuICAgIC8qKiBTdG9wIG1lZGlhQ2hhbmdlIGV2ZW50IHByb3BhZ2F0aW9uIGluIGV2ZW50IHN0cmVhbXMgKi9cbiAgICBibG9ja1Byb3BhZ2F0aW9uKCk6IChldmVudDogTWVkaWFDaGFuZ2UpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2F2ZSBjdXJyZW50IGFjdGl2YXRlQnJlYWtwb2ludHMgKGZvciBsYXRlciByZXN0b3JlKVxuICAgICAqIGFuZCBzdWJzdGl0dXRlIG9ubHkgdGhlIHByaW50QWxpYXMgYnJlYWtwb2ludFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzdGFydFByaW50aW5nKHRhcmdldDogSG9va1RhcmdldCwgYnBMaXN0OiBPcHRpb25hbEJyZWFrUG9pbnRbXSk6IHZvaWQ7XG4gICAgLyoqIEZvciBhbnkgcHJpbnQgZGUtYWN0aXZhdGlvbnMsIHJlc2V0IHRoZSBlbnRpcmUgcHJpbnQgcXVldWUgKi9cbiAgICBwcm90ZWN0ZWQgc3RvcFByaW50aW5nKHRhcmdldDogSG9va1RhcmdldCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVG8gcmVzdG9yZSBwcmUtUHJpbnQgQWN0aXZhdGlvbnMsIHdlIG11c3QgY2FwdHVyZSB0aGUgcHJvcGVyXG4gICAgICogbGlzdCBvZiBicmVha3BvaW50IGFjdGl2YXRpb25zIEJFRk9SRSBwcmludCBzdGFydHMuIE9uQmVmb3JlUHJpbnQoKVxuICAgICAqIGlzIG5vdCBzdXBwb3J0ZWQ7IHNvICdwcmludCcgbWVkaWFRdWVyeSBhY3RpdmF0aW9ucyBtdXN0IGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiA+ICBCdXQgYWN0aXZhdGVkIGJyZWFrcG9pbnRzIGFyZSBkZWFjdGl2YXRlZCBCRUZPUkUgJ3ByaW50JyBhY3RpdmF0aW9uLlxuICAgICAqXG4gICAgICogTGV0J3MgY2FwdHVyZSBhbGwgZGUtYWN0aXZhdGlvbnMgdXNpbmcgdGhlIGZvbGxvd2luZyBsb2dpYzpcbiAgICAgKlxuICAgICAqICBXaGVuIG5vdCBwcmludGluZzpcbiAgICAgKiAgICAtIGNsZWFyIGNhY2hlIHdoZW4gYWN0aXZhdGluZyBub24tcHJpbnQgYnJlYWtwb2ludFxuICAgICAqICAgIC0gdXBkYXRlIGNhY2hlIChhbmQgc29ydCkgd2hlbiBkZWFjdGl2YXRpbmdcbiAgICAgKlxuICAgICAqICBXaGVuIHByaW50aW5nOlxuICAgICAqICAgIC0gc29ydCBhbmQgc2F2ZSB3aGVuIHN0YXJ0aW5nIHByaW50XG4gICAgICogICAgLSByZXN0b3JlIGFzIGFjdGl2YXRlZFRhcmdldHMgYW5kIGNsZWFyIHdoZW4gc3RvcCBwcmludGluZ1xuICAgICAqL1xuICAgIGNvbGxlY3RBY3RpdmF0aW9ucyhldmVudDogTWVkaWFDaGFuZ2UpOiB2b2lkO1xuICAgIC8qKiBJcyB0aGlzIHNlcnZpY2UgY3VycmVudGx5IGluIFByaW50LW1vZGUgPyAqL1xuICAgIHByaXZhdGUgaXNQcmludGluZztcbiAgICBwcml2YXRlIHF1ZXVlO1xuICAgIHByaXZhdGUgZGVhY3RpdmF0aW9ucztcbn1cbiJdfQ==